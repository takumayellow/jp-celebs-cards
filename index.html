<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>芸能人 暗記カード（ローカル）</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<header class="topbar">
  <h1>芸能人 暗記カード</h1>
  <div class="controls">
    <input id="q" type="search" placeholder="検索（名前・よみ・カテゴリ）" />
    <select id="filterCat">
      <option value="">すべてのカテゴリ</option>
    </select>
    <button id="shuffleBtn">シャッフル</button>
    <button id="resetBtn" title="進捗をリセット">リセット</button>
  </div>
</header>

<main class="wrap">
  <aside class="stats">
    <div>総数: <span id="countTotal">0</span></div>
    <div>残り: <span id="countLeft">0</span></div>
    <div>既学習: <span id="countKnown">0</span></div>
  </aside>

  <section id="card" class="card">
    <div class="imgWrap">
      <img id="face" alt="photo" />
      <div id="noimg" class="noimg">画像なし</div>
    </div>
    <div class="front" id="front">
      <div class="hint">写真 → 名前を推測</div>
    </div>
    <div class="back" id="back">
      <div class="name" id="name"></div>
      <div class="yomi" id="yomi"></div>
      <div class="cat" id="cat"></div>
    </div>
  </section>

  <section class="buttons">
    <button id="flipBtn">答えを見る [Space]</button>
    <button id="againBtn">あとで [←]</button>
    <button id="okBtn" class="ok">わかった [→]</button>
  </section>

  <section class="help">
    <details>
      <summary>画像の入れ方 / 運用メモ</summary>
      <ol>
        <li><code>images</code> フォルダに顔写真ファイルを入れる。</li>
        <li>原則のファイル名は <code>images/&lt;id&gt;.jpg</code> 形式（IDはデータ側で付与済み）。</li>
        <li>拡張子は <code>.jpg/.jpeg/.png/.webp</code> に対応（同じIDに複数ある場合は .jpg 優先）。</li>
        <li>画像が無いカードは「画像なし」プレースホルダが出る。</li>
      </ol>
      <p>※ ライセンス・肖像権に注意。個人の学習利用に限定し、配布は避けること。</p>
    </details>

    <details>
      <summary>データの編集（全部ターミナル）</summary>
      <ol>
        <li><code>data\cards.tsv</code> を増補（TSV：<code>nameyomicategoryid(optional)</code>）。</li>
        <li>以下を実行：<br>
          <code>powershell -ExecutionPolicy Bypass .\tools\build.ps1</code>
        </li>
        <li><code>index.html</code> を再読み込み。</li>
      </ol>
    </details>
  </section>
</main><script id="datajs-shim">
/* shim: app.js が期待する DATA_TSV を必ず用意する */
(function(w){
  // 空 TSV（ヘッダ行のみ）。本物のデータは boot スクリプトで with_images.tsv から供給する
  w.DATA_TSV = "name\tyomi\tcategory\tid\n";
})(window);
</script>
</script>
<div class="hud"><span>総数: <b id="count-total">0</b></span>　<span>残り: <b id="count-rest">0</b></span></div><div id="controls"><input id="q" placeholder="検索（名前・よみ・カテ）"/><select id="cat"></select><button id="prev">←</button><button id="next">→</button><button id="shuffle">シャッフル</button><button id="reset">リセット</button></div><div id="card" class="card"></div><!-- === counters + deck boot === -->
<div id="img-counters" style="margin:8px 0; opacity:.9; display:flex; gap:12px; font-size:.95rem">
  <div>総数: <b id="countTotal">0</b></div>
  <div>画像あり: <b id="countWithImg">0</b></div>
  <div>欠落: <b id="countMissing">0</b></div>
  <div>画像ファイル: <b id="countImages">0</b></div>
</div>

<script>
(async () => {
  try {
    const r = await fetch('data/metrics.json', {cache:'no-store'});
    if (!r.ok) return;
    const m = await r.json();
    const g = id => document.getElementById(id);
    if (g('countTotal'))   g('countTotal').textContent   = m.total   ?? 0;
    if (g('countWithImg')) g('countWithImg').textContent = m.withImg ?? 0;
    if (g('countMissing')) g('countMissing').textContent = m.missing ?? 0;
    if (g('countImages'))  g('countImages').textContent  = m.images  ?? 0;
  } catch {}
})();

// 画像があるカードだけで学習を開始（app.js 側に startStudy(cards) がある前提）
async function ensureDeck(){
  try {
    const r = await fetch('data/with_images.tsv', {cache:'no-store'});
    if (!r.ok) return false;
    const t = await r.text();
    if (!window.tsvParse) return false;
    const cards = tsvParse(t);
    if (!cards || !cards.length) return false;
    if (typeof startStudy === 'function') startStudy(cards);
    return true;
  } catch { return false; }
}
setTimeout(() => { ensureDeck(); }, 500);
</script>
<!-- === /counters + deck boot === -->


<!-- boot injected -->
<script>
// デッキ読込→UI開始
(async ()=>{
  const toUrl = u => u+(u.includes("?")?"&":"?")+"v="+Date.now();
  const tsvParse = (t)=>{
    const lines=t.trim().split(/\r?\n/);
    const head = lines.shift().split('\t');
    return lines.map(l=>{
      const cols=l.split('\t'), o={};
      head.forEach((h,i)=>o[h]=cols[i]??'');
      return o;
    });
  };

  // 1) TSV/マップ読込
  const tsvTxt = await fetch(toUrl('data/with_images.tsv'), {cache:'no-store'}).then(r=>r.ok?r.text():'').catch(()=> '');
  if(!tsvTxt){ console.warn('with_images.tsv not found'); return; }
  const rows = tsvParse(tsvTxt);
  const map  = await fetch(toUrl('data/attr_map.json'), {cache:'no-store'}).then(r=>r.ok?r.json():{}).catch(()=> ({}));

  // 2) 画像があるカードだけ残して image パス付与
  const deck = rows.filter(c => map[c.id]).map(c => ({...c, image: 'images/' + map[c.id]}));

  // 3) グローバルに載せてUI起動
  window.cards = deck;
  window.currentDeck = deck;

  if (typeof window.startStudy === 'function') {
    window.startStudy(deck);
  } else {
    // フォールバック：最初の画像を直接描画（img要素推測）
    const img = document.querySelector('img#photo, img#card-img, .card img, img');
    if (img && deck[0]?.image) img.src = deck[0].image;
  }
})();
</script>
<!-- boot injected v2 -->
<script>
(async () => {
  // 画像カウンタ表示（存在する時だけ）
  try{
    const r = await fetch('data/metrics.json?'+Date.now());
    if(r.ok){
      const m = await r.json();
      const wrap = document.getElementById('img-counters') || (function(){
        const d = document.createElement('div');
        d.id = 'img-counters';
        d.style.margin = '8px 0'; d.style.opacity='0.9';
        d.innerHTML = '画像あり: <span id="countWithImg">0</span> / 総数: <span id="countTotal">0</span>（欠落: <span id="countMissing">0</span> / 画像ファイル: <span id="countImages">0</span>）';
        document.body.insertBefore(d, document.body.firstChild);
        return d;
      })();
      const g = id => document.getElementById(id);
      g('countWithImg').textContent = m.withImg ?? 0;
      g('countTotal').textContent   = m.total   ?? 0;
      g('countMissing').textContent = m.missing ?? 0;
      g('countImages').textContent  = m.images  ?? 0;
    }
  }catch(e){}

  // デッキ読み込み（with_images.tsv + attr_map.json）
  // ヘッダのBOM/列順の差を吸収して id/name/yomi/category を取り出し、image を付与
  try{
    const [tsvRes, mapRes] = await Promise.all([
      fetch('data/with_images.tsv?'+Date.now()),
      fetch('data/attr_map.json?'+Date.now())
    ]);
    if(!tsvRes.ok || !mapRes.ok) return;

    const tsv = await tsvRes.text();
    const map = await mapRes.json();

    const lines  = tsv.replace(/^\uFEFF/, '').split(/\r?\n/).filter(Boolean);
    const header = lines.shift().split('\t');
    const col = Object.fromEntries(header.map((h,i)=>[h.trim(), i]));
    const need = ['id','name','yomi','category'].every(k => k in col);
    if(!need) return;

    const deck = lines.map(row => {
      const c = row.split('\t');
      const id = c[col['id']];
      const fname = map[id] || (id + '.jpg');
      return {
        id, name: c[col['name']], yomi: c[col['yomi']], category: c[col['category']],
        image: 'images/' + fname
      };
    });

    // 既存UIが見に行うように共有変数に置く + 既存 startStudy を呼ぶ
    window.cards = deck;
    if (typeof window.startStudy === 'function') window.startStudy(deck);
  }catch(e){}
})();
</script>
<script id="boot-with-images">
(async ()=>{
  // --- helpers ---
  const stripBom=s=>s&&s.charCodeAt(0)===0xFEFF?s.slice(1):s;
  const tsvParse=t=>{
    t=stripBom(t);
    const ls=t.split(/\r?\n/).filter(Boolean);
    if(ls.length===0) return [];
    const keys=ls.shift().split('\t');
    return ls.map(l=>{
      const v=l.split('\t'); const o={};
      for(let i=0;i<keys.length;i++) o[keys[i]]=v[i];
      return o;
    });
  };
  const waitFor=(pred,timeout=5000)=>new Promise(r=>{
    const t=Date.now(); const id=setInterval(()=>{
      if(pred()||Date.now()-t>timeout){clearInterval(id);r();}
    },50);
  });

  try{
    // データ取得
    const [t,attrJson] = await Promise.all([
      fetch('data/with_images.tsv',{cache:'no-store'}).then(r=>r.ok?r.text():''),
      fetch('data/attr_map.json',{cache:'no-store'}).then(r=>r.ok?r.json():{})
    ]);
    const cards = t ? tsvParse(t) : [];
    const attr  = new Map(Object.entries(attrJson));
    const deck  = cards.filter(c=>attr.has(c.id));
    deck.forEach(c=>c.image = 'images/' + attr.get(c.id));

    // グローバルへ渡す（アプリ側が参照できるように）
    window.cards = deck;
    window.currentDeck = deck;

    // アプリ初期化待ち → startStudy 呼び出し
    await waitFor(()=>typeof window.startStudy==='function', 6000);
    if(typeof window.startStudy==='function'){
      window.startStudy(deck);
      console.log('[boot] startStudy with', deck.length, 'cards');
    }else{
      console.warn('[boot] startStudy not found; deck only set globally.');
    }
  }catch(e){
    console.error('[boot error]', e);
  }
})();
</script>
<!-- boot: robust deck builder (cards.tsv + attr_map.json) -->
<script id="boot-images-v3">
(async () => {
  // 小道具
  const txt = async (u)=>{try{const r=await fetch(u,{cache:"no-store"}); return r.ok?await r.text():"";}catch{ return ""}};
  const json= async (u)=>{try{const r=await fetch(u,{cache:"no-store"}); return r.ok?await r.json():{};}catch{ return {}}};
  const csv = t => t.replace(/^\uFEFF/,"").trim().split(/\r?\n/).map(l=>l.split("\t"));
  const alias = c => { c.photo=c.photo||c.image; c.img=c.img||c.image; c.imageUrl=c.imageUrl||c.image; return c; };

  try{
    // 1) まず with_images.tsv を試す（ダメなら cards.tsv にフォールバック）
    let rows = [];
    const w = await txt("data/with_images.tsv");
    if(w){
      const a = csv(w); const head=a.shift(); const col=Object.fromEntries(head.map((h,i)=>[h,i]));
      rows = a.filter(r=>r.length>=4).map(r=>({
        id:r[col?.id ?? 3], name:r[col?.name ?? 0], yomi:r[col?.yomi ?? 1], category:r[col?.category ?? 2],
        image:r[col?.image ?? 4] || ""  // 列が無い場合は後で map から埋める
      }));
    }
    if(rows.length===0){
      const t = await txt("data/cards.tsv");
      if(t){
        const a = csv(t); const head=a.shift(); const col=Object.fromEntries(head.map((h,i)=>[h,i]));
        rows = a.filter(r=>r.length>=4).map(r=>({
          id:r[col?.id ?? 3], name:r[col?.name ?? 0], yomi:r[col?.yomi ?? 1], category:r[col?.category ?? 2]
        }));
      }
    }

    // 2) 画像ファイル名マップを適用
    const map = await json("data/attr_map.json");
    const deck = rows.filter(c => map[c.id]).map(c => alias({...c, image: `images/${map[c.id]}`}));

    // 3) グローバルに載せる（既存UI互換）
    window.cards = rows;
    window.currentDeck = deck;

    // 4) カウンタ（存在すれば）更新
    const m = await json("data/metrics.json");
    const g = id => document.getElementById(id);
    if(m && g('countTotal')){ g('countTotal').textContent   = m.total ?? 0;
      g('countWithImg').textContent = m.withImg ?? 0;
      g('countImages').textContent  = m.images ?? 0;
      g('countMissing').textContent = m.missing ?? 0;
    }

    // 5) UI起動（startStudy 等が定義されるまで待って呼ぶ）
    let tries = 0;
    (function boot(){
      const f = window.startStudy || window.startStudyWithDeck || window.init || window.boot;
      if(typeof f === "function"){ f(window.currentDeck); }
      else if(tries++ < 60){ setTimeout(boot, 100); }
      else { console.warn("[boot-images] start function not found"); }
    })();

    console.info("[boot-images] rows=", rows.length, "deck=", deck.length);
  }catch(e){ console.error("[boot-images]", e); }
})();
</script>

<script id="boot-images-v4">
(()=>{ const log=(...a)=>console.log('[boot-images]',...a);
const idStr=x=>(''+x).trim();
const tsvParse=t=>{
  const s=t.replace(/^\uFEFF/,'').trim();
  const lines=s? s.split(/\r?\n/):[];
  if(lines.length<2) return [];
  const head=lines.shift().split('\t');
  return lines.filter(Boolean).map(r=>{
    const v=r.split('\t'),o={};
    for(let i=0;i<head.length;i++) o[head[i]]=v[i];
    return o;
  });
};
async function loadAttr(){
  try{
    const r=await fetch('data/attr_map.json?'+Math.random(),{cache:'no-store'});
    if(!r.ok) return new Map();
    return new Map(Object.entries(await r.json()));
  }catch{ return new Map(); }
}
async function ensureDeck(){
  try{
    const txt=await fetch('data/with_images.tsv?'+Math.random(),{cache:'no-store'}).then(r=>r.ok?r.text():'');
    if(!txt){ log('no with_images.tsv'); return false; }
    const rows=tsvParse(txt);
    const attr=await loadAttr();
    const deck=rows.filter(c=>attr.has(idStr(c.id)));
    deck.forEach(c=> c.image='images/'+attr.get(idStr(c.id)));
    window.currentDeck=deck; log('rows=',rows.length,'deck=',deck.length);
    if(typeof window.startStudy==='function'){ window.startStudy(deck); }
    return deck.length>0;
  }catch(e){ console.error(e); return false; }
}
ensureDeck();
})();
</script>
<!-- images patch: url fix + cache bust -->
<script>
(function(){
  const version = Date.now().toString();
  let map = {};
  function fix(img){
    try{
      const url = new URL(img.src, location.href);
      if(!/\/images\//.test(url.pathname)) return;
      const file = url.pathname.split('/').pop();           // 例: 0001.jpg
      const base = file.split('.')[0];                      // 例: 0001
      const real = map[base] || map[base.padStart(4,'0')] || '';
      if(real && file !== real){
        img.src = images/?v=;
      }else if(!/\.(jpg|jpeg|png)$/i.test(file) && real){
        img.src = images/?v=;
      }else{
        // せめてキャッシュバスト
        img.src = url.pathname + '?v=' + version;
      }
    }catch(e){}
  }
  function scan(){
    document.querySelectorAll('img').forEach(fix);
  }
  // 変更検知で常に補正
  const mo = new MutationObserver(muts=>{
    for(const m of muts){
      for(const n of m.addedNodes||[]){
        if(n.nodeType===1){
          if(n.tagName==='IMG') fix(n);
          n.querySelectorAll && n.querySelectorAll('img').forEach(fix);
        }
      }
      if(m.type==='attributes' && m.target.tagName==='IMG' && m.attributeName==='src'){ fix(m.target); }
    }
  });
  mo.observe(document.documentElement,{childList:true,subtree:true,attributes:true,attributeFilter:['src']});

  fetch('data/attr_map.json?v='+version).then(r=>r.ok?r.json():{}).then(j=>{
    map = j || {};
    if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', scan); }
    else { scan(); }
  }).catch(()=>{ /* mapが読めなくても動作継続 */ });
})();
</script>
<script>
/* === images patch: id->filename + cache-bust === */
(function(){
  const ver = (new URL(location.href)).searchParams.get('v') || Date.now().toString(36);
  let MAP = {};

  function fixImg(img){
    try{
      const url  = new URL(img.src || '', location.href);
      const base = (url.pathname.split('/').pop() || '').replace(/\?.*$/,''); // 現在のファイル名(拡張子なし想定)
      // id とみなして、マップか、なければ .jpg を仮定して差し替え
      if(!/\.(png|jpe?g)$/i.test(base)){
        const id   = base || (img.dataset && img.dataset.id) || '';
        if(!id) return;
        const file = MAP[id] || (id + '.jpg');
        img.src = `images/${file}?v=${ver}`;
      }else{
        // 既に拡張子付きなら cache-bust だけ付与
        if(!/[?&]v=/.test(url.search)) img.src = url.pathname + `?v=${ver}`;
      }
    }catch(e){}
  }

  function boot(){
    document.querySelectorAll('img').forEach(fixImg);
    const mo = new MutationObserver(ms => {
      ms.forEach(m => {
        m.addedNodes.forEach(n => {
          if(n.nodeType===1 && n.tagName==='IMG') fixImg(n);
          if(n.nodeType===1 && n.querySelectorAll) n.querySelectorAll('img').forEach(fixImg);
        });
        if(m.type==='attributes' && m.target.tagName==='IMG' && m.attributeName==='src') fixImg(m.target);
      });
    });
    mo.observe(document.documentElement,{childList:true,subtree:true,attributes:true,attributeFilter:['src']});
  }

  fetch('data/attr_map.json?v='+ver).then(r => r.ok ? r.json() : ({})).then(j => {
    MAP = j || {};
    if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', boot); } else { boot(); }
  }).catch(()=>boot());
})();
</script>
<!-- images patch: inline map + cache bust -->
<script>
const bust = Date.now(); window.__ver = bust;
fetch('data/attr_map.json?v='+bust).then(r=>r.ok?r.json():{}).then(j=>{ window.__map=j||{}; });
</script>
<!-- images patch: map+fallback+cache-bust -->
<script>
(function(){
  const bust = Date.now();
  // 1) マップを取得（キャッシュバスト付）
  window.__map = {};
  fetch('data/attr_map.json?v='+bust)
    .then(r => r.ok ? r.json() : {})
    .then(j => { window.__map = j || {}; });

  // 2) id -> 画像URL への解決
  function toUrl(id){
    const m  = window.__map || {};
    const fn = m[id];
    return fn ? ('images/'+fn) : ('images/'+id+'.jpg');
  }

  // 3) 1枚適用（拡張子なし src を置換し、jpg失敗時にpngへフォールバック）
  function applyOne(img){
    const src = img.getAttribute('src') || '';
    if(/\.(jpe?g|png)(\?|#|$)/i.test(src)) return; // すでに拡張子あり
    const m = src.match(/images\/([0-9]{3,6})/);   // images/0001 形式を想定
    if(!m) return;
    const id = m[1];
    img.src = toUrl(id) + '?v='+bust;
    img.onerror = function(){
      if(img.dataset.fallbackTried) return;
      img.dataset.fallbackTried = '1';
      img.src = 'images/'+id+'.png?v='+bust;
    };
  }

  // 4) 全体スキャン＋MutationObserverで動的変更にも追従
  function scan(){
    document.querySelectorAll('img[src*="images/"]').forEach(applyOne);
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', scan);
  }else{
    scan();
  }
  const mo = new MutationObserver(ms => {
    for(const m of ms){
      if(m.type === 'attributes' && m.attributeName === 'src' && m.target.tagName === 'IMG'){
        applyOne(m.target);
      }
      if(m.type === 'childList'){ scan(); }
    }
  });
  mo.observe(document.documentElement, {subtree:true, childList:true, attributes:true, attributeFilter:['src']});
})();
</script>
<!-- images patch: url mapping + ext fallback + cache-bust -->
<script>
/* images patch: url mapping + ext fallback + cache-bust */
(() => {
  const bust = Date.now();
  // 1) 画像ファイル名マップを取得（id => 実ファイル名）
  window.__imgMap = window.__imgMap || {};
  fetch('data/attr_map.json?v=' + bust)
    .then(r => r.ok ? r.json() : {})
    .then(j => { window.__imgMap = j || {}; boot(); })
    .catch(() => boot());

  function buildList(id) {
    const fn = (window.__imgMap && window.__imgMap[id]) || (id + '.jpg');
    const list = ['images/' + fn];           // マップされた実ファイル
    if(!/\.png$/i.test(fn)) list.push('images/' + id + '.png'); // jpg→png フォールバック候補
    return list.map(u => u + '?v=' + bust);  // cache-bust
  }

  function getIdFromImg(img) {
    // data-id 優先、だめなら src から 連番っぽい数字を拾う
    const d = img.getAttribute('data-id');
    if (d && /^\d+$/.test(d)) return d;
    const m = (img.getAttribute('src') || '').match(/(\d{3,})/);
    return m ? m[1] : null;
  }

  function applyOne(img) {
    if (img.__patched) return;
    const id = getIdFromImg(img);
    if (!id) return;
    const list = buildList(id);
    let i = 0;
    const set = () => { img.src = list[i]; };
    img.addEventListener('error', () => { if (++i < list.length) set(); }, { passive:true });
    img.__patched = true;
    set();
  }

  function scan() {
    document.querySelectorAll('img[data-id], img[src*="images/"]').forEach(applyOne);
  }

  function boot() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', scan, { once:true });
    } else {
      scan();
    }
    // 動的追加にも追従
    new MutationObserver(() => scan())
      .observe(document.documentElement, { subtree:true, childList:true, attributes:true, attributeFilter:['src'] });
  }
})();
</script>
</body>
</html>















