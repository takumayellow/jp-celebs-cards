<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>芸能人 暗記カード（ローカル）</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<header class="topbar">
  <h1>芸能人 暗記カード</h1>
  <div class="controls">
    <input id="q" type="search" placeholder="検索（名前・よみ・カテゴリ）" />
    <select id="filterCat">
      <option value="">すべてのカテゴリ</option>
    </select>
    <button id="shuffleBtn">シャッフル</button>
    <button id="resetBtn" title="進捗をリセット">リセット</button>
  </div>
</header>

<main class="wrap">
  <aside class="stats">
    <div>総数: <span id="countTotal">0</span></div>
    <div>残り: <span id="countLeft">0</span></div>
    <div>既学習: <span id="countKnown">0</span></div>
  </aside>

  <section id="card" class="card">
    <div class="imgWrap">
      <img id="face" alt="photo" />
      <div id="noimg" class="noimg">画像なし</div>
    </div>
    <div class="front" id="front">
      <div class="hint">写真 → 名前を推測</div>
    </div>
    <div class="back" id="back">
      <div class="name" id="name"></div>
      <div class="yomi" id="yomi"></div>
      <div class="cat" id="cat"></div>
    </div>
  </section>

  <section class="buttons">
    <button id="flipBtn">答えを見る [Space]</button>
    <button id="againBtn">あとで [←]</button>
    <button id="okBtn" class="ok">わかった [→]</button>
  </section>

  <section class="help">
    <details>
      <summary>画像の入れ方 / 運用メモ</summary>
      <ol>
        <li><code>images</code> フォルダに顔写真ファイルを入れる。</li>
        <li>原則のファイル名は <code>images/&lt;id&gt;.jpg</code> 形式（IDはデータ側で付与済み）。</li>
        <li>拡張子は <code>.jpg/.jpeg/.png/.webp</code> に対応（同じIDに複数ある場合は .jpg 優先）。</li>
        <li>画像が無いカードは「画像なし」プレースホルダが出る。</li>
      </ol>
      <p>※ ライセンス・肖像権に注意。個人の学習利用に限定し、配布は避けること。</p>
    </details>

    <details>
      <summary>データの編集（全部ターミナル）</summary>
      <ol>
        <li><code>data\cards.tsv</code> を増補（TSV：<code>nameyomicategoryid(optional)</code>）。</li>
        <li>以下を実行：<br>
          <code>powershell -ExecutionPolicy Bypass .\tools\build.ps1</code>
        </li>
        <li><code>index.html</code> を再読み込み。</li>
      </ol>
    </details>
  </section>
</main><script src="app.js"></script>
<div class="hud"><span>総数: <b id="count-total">0</b></span>　<span>残り: <b id="count-rest">0</b></span></div><div id="controls"><input id="q" placeholder="検索（名前・よみ・カテ）"/><select id="cat"></select><button id="prev">←</button><button id="next">→</button><button id="shuffle">シャッフル</button><button id="reset">リセット</button></div><div id="card" class="card"></div><!-- === counters + deck boot === -->
<div id="img-counters" style="margin:8px 0; opacity:.9; display:flex; gap:12px; font-size:.95rem">
  <div>総数: <b id="countTotal">0</b></div>
  <div>画像あり: <b id="countWithImg">0</b></div>
  <div>欠落: <b id="countMissing">0</b></div>
  <div>画像ファイル: <b id="countImages">0</b></div>
</div>

<script>
(async () => {
  try {
    const r = await fetch('data/metrics.json', {cache:'no-store'});
    if (!r.ok) return;
    const m = await r.json();
    const g = id => document.getElementById(id);
    if (g('countTotal'))   g('countTotal').textContent   = m.total   ?? 0;
    if (g('countWithImg')) g('countWithImg').textContent = m.withImg ?? 0;
    if (g('countMissing')) g('countMissing').textContent = m.missing ?? 0;
    if (g('countImages'))  g('countImages').textContent  = m.images  ?? 0;
  } catch {}
})();

// 画像があるカードだけで学習を開始（app.js 側に startStudy(cards) がある前提）
async function ensureDeck(){
  try {
    const r = await fetch('data/with_images.tsv', {cache:'no-store'});
    if (!r.ok) return false;
    const t = await r.text();
    if (!window.tsvParse) return false;
    const cards = tsvParse(t);
    if (!cards || !cards.length) return false;
    if (typeof startStudy === 'function') startStudy(cards);
    return true;
  } catch { return false; }
}
setTimeout(() => { ensureDeck(); }, 500);
</script>
<!-- === /counters + deck boot === -->


<!-- boot injected -->
<script>
// デッキ読込→UI開始
(async ()=>{
  const toUrl = u => u+(u.includes("?")?"&":"?")+"v="+Date.now();
  const tsvParse = (t)=>{
    const lines=t.trim().split(/\r?\n/);
    const head = lines.shift().split('\t');
    return lines.map(l=>{
      const cols=l.split('\t'), o={};
      head.forEach((h,i)=>o[h]=cols[i]??'');
      return o;
    });
  };

  // 1) TSV/マップ読込
  const tsvTxt = await fetch(toUrl('data/with_images.tsv'), {cache:'no-store'}).then(r=>r.ok?r.text():'').catch(()=> '');
  if(!tsvTxt){ console.warn('with_images.tsv not found'); return; }
  const rows = tsvParse(tsvTxt);
  const map  = await fetch(toUrl('data/attr_map.json'), {cache:'no-store'}).then(r=>r.ok?r.json():{}).catch(()=> ({}));

  // 2) 画像があるカードだけ残して image パス付与
  const deck = rows.filter(c => map[c.id]).map(c => ({...c, image: 'images/' + map[c.id]}));

  // 3) グローバルに載せてUI起動
  window.cards = deck;
  window.currentDeck = deck;

  if (typeof window.startStudy === 'function') {
    window.startStudy(deck);
  } else {
    // フォールバック：最初の画像を直接描画（img要素推測）
    const img = document.querySelector('img#photo, img#card-img, .card img, img');
    if (img && deck[0]?.image) img.src = deck[0].image;
  }
})();
</script>
<!-- boot injected v2 -->
<script>
(async () => {
  // 画像カウンタ表示（存在する時だけ）
  try{
    const r = await fetch('data/metrics.json?'+Date.now());
    if(r.ok){
      const m = await r.json();
      const wrap = document.getElementById('img-counters') || (function(){
        const d = document.createElement('div');
        d.id = 'img-counters';
        d.style.margin = '8px 0'; d.style.opacity='0.9';
        d.innerHTML = '画像あり: <span id="countWithImg">0</span> / 総数: <span id="countTotal">0</span>（欠落: <span id="countMissing">0</span> / 画像ファイル: <span id="countImages">0</span>）';
        document.body.insertBefore(d, document.body.firstChild);
        return d;
      })();
      const g = id => document.getElementById(id);
      g('countWithImg').textContent = m.withImg ?? 0;
      g('countTotal').textContent   = m.total   ?? 0;
      g('countMissing').textContent = m.missing ?? 0;
      g('countImages').textContent  = m.images  ?? 0;
    }
  }catch(e){}

  // デッキ読み込み（with_images.tsv + attr_map.json）
  // ヘッダのBOM/列順の差を吸収して id/name/yomi/category を取り出し、image を付与
  try{
    const [tsvRes, mapRes] = await Promise.all([
      fetch('data/with_images.tsv?'+Date.now()),
      fetch('data/attr_map.json?'+Date.now())
    ]);
    if(!tsvRes.ok || !mapRes.ok) return;

    const tsv = await tsvRes.text();
    const map = await mapRes.json();

    const lines  = tsv.replace(/^\uFEFF/, '').split(/\r?\n/).filter(Boolean);
    const header = lines.shift().split('\t');
    const col = Object.fromEntries(header.map((h,i)=>[h.trim(), i]));
    const need = ['id','name','yomi','category'].every(k => k in col);
    if(!need) return;

    const deck = lines.map(row => {
      const c = row.split('\t');
      const id = c[col['id']];
      const fname = map[id] || (id + '.jpg');
      return {
        id, name: c[col['name']], yomi: c[col['yomi']], category: c[col['category']],
        image: 'images/' + fname
      };
    });

    // 既存UIが見に行うように共有変数に置く + 既存 startStudy を呼ぶ
    window.cards = deck;
    if (typeof window.startStudy === 'function') window.startStudy(deck);
  }catch(e){}
})();
</script>
<script id="boot-with-images">
(async ()=>{
  // --- helpers ---
  const stripBom=s=>s&&s.charCodeAt(0)===0xFEFF?s.slice(1):s;
  const tsvParse=t=>{
    t=stripBom(t);
    const ls=t.split(/\r?\n/).filter(Boolean);
    if(ls.length===0) return [];
    const keys=ls.shift().split('\t');
    return ls.map(l=>{
      const v=l.split('\t'); const o={};
      for(let i=0;i<keys.length;i++) o[keys[i]]=v[i];
      return o;
    });
  };
  const waitFor=(pred,timeout=5000)=>new Promise(r=>{
    const t=Date.now(); const id=setInterval(()=>{
      if(pred()||Date.now()-t>timeout){clearInterval(id);r();}
    },50);
  });

  try{
    // データ取得
    const [t,attrJson] = await Promise.all([
      fetch('data/with_images.tsv',{cache:'no-store'}).then(r=>r.ok?r.text():''),
      fetch('data/attr_map.json',{cache:'no-store'}).then(r=>r.ok?r.json():{})
    ]);
    const cards = t ? tsvParse(t) : [];
    const attr  = new Map(Object.entries(attrJson));
    const deck  = cards.filter(c=>attr.has(c.id));
    deck.forEach(c=>c.image = 'images/' + attr.get(c.id));

    // グローバルへ渡す（アプリ側が参照できるように）
    window.cards = deck;
    window.currentDeck = deck;

    // アプリ初期化待ち → startStudy 呼び出し
    await waitFor(()=>typeof window.startStudy==='function', 6000);
    if(typeof window.startStudy==='function'){
      window.startStudy(deck);
      console.log('[boot] startStudy with', deck.length, 'cards');
    }else{
      console.warn('[boot] startStudy not found; deck only set globally.');
    }
  }catch(e){
    console.error('[boot error]', e);
  }
})();
</script>
<!-- boot: robust deck builder (cards.tsv + attr_map.json) -->
<script id="boot-images-v3">
(async () => {
  // 小道具
  const txt = async (u)=>{try{const r=await fetch(u,{cache:"no-store"}); return r.ok?await r.text():"";}catch{ return ""}};
  const json= async (u)=>{try{const r=await fetch(u,{cache:"no-store"}); return r.ok?await r.json():{};}catch{ return {}}};
  const csv = t => t.replace(/^\uFEFF/,"").trim().split(/\r?\n/).map(l=>l.split("\t"));
  const alias = c => { c.photo=c.photo||c.image; c.img=c.img||c.image; c.imageUrl=c.imageUrl||c.image; return c; };

  try{
    // 1) まず with_images.tsv を試す（ダメなら cards.tsv にフォールバック）
    let rows = [];
    const w = await txt("data/with_images.tsv");
    if(w){
      const a = csv(w); const head=a.shift(); const col=Object.fromEntries(head.map((h,i)=>[h,i]));
      rows = a.filter(r=>r.length>=4).map(r=>({
        id:r[col?.id ?? 3], name:r[col?.name ?? 0], yomi:r[col?.yomi ?? 1], category:r[col?.category ?? 2],
        image:r[col?.image ?? 4] || ""  // 列が無い場合は後で map から埋める
      }));
    }
    if(rows.length===0){
      const t = await txt("data/cards.tsv");
      if(t){
        const a = csv(t); const head=a.shift(); const col=Object.fromEntries(head.map((h,i)=>[h,i]));
        rows = a.filter(r=>r.length>=4).map(r=>({
          id:r[col?.id ?? 3], name:r[col?.name ?? 0], yomi:r[col?.yomi ?? 1], category:r[col?.category ?? 2]
        }));
      }
    }

    // 2) 画像ファイル名マップを適用
    const map = await json("data/attr_map.json");
    const deck = rows.filter(c => map[c.id]).map(c => alias({...c, image: `images/${map[c.id]}`}));

    // 3) グローバルに載せる（既存UI互換）
    window.cards = rows;
    window.currentDeck = deck;

    // 4) カウンタ（存在すれば）更新
    const m = await json("data/metrics.json");
    const g = id => document.getElementById(id);
    if(m && g('countTotal')){ g('countTotal').textContent   = m.total ?? 0;
      g('countWithImg').textContent = m.withImg ?? 0;
      g('countImages').textContent  = m.images ?? 0;
      g('countMissing').textContent = m.missing ?? 0;
    }

    // 5) UI起動（startStudy 等が定義されるまで待って呼ぶ）
    let tries = 0;
    (function boot(){
      const f = window.startStudy || window.startStudyWithDeck || window.init || window.boot;
      if(typeof f === "function"){ f(window.currentDeck); }
      else if(tries++ < 60){ setTimeout(boot, 100); }
      else { console.warn("[boot-images] start function not found"); }
    })();

    console.info("[boot-images] rows=", rows.length, "deck=", deck.length);
  }catch(e){ console.error("[boot-images]", e); }
})();
</script>
</body>
</html>








